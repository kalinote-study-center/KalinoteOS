     1                                  ; kalinote-os
     2                                  ; TAB=4
     3                                  
     4                                  ; [INSTRSET "i486p"]
     5                                  
     6                                  VBEMODE	EQU		0x118			; 1024x768x32bit色彩
     7                                  BOTPAK	EQU		0x00280000		; bootpack安装位置
     8                                  DSKCAC	EQU		0x00100000		; 磁盘缓存位置
     9                                  DSKCAC0	EQU		0x00008000		; 磁盘缓存位置（实时模式）
    10                                  
    11                                  ; 色彩代码：
    12                                  ;	0x100 :  640 x  400 x 8bit
    13                                  ;	0x101 :  640 x  480 x 8bit
    14                                  ;	0x103 :  800 x  600 x 8bit
    15                                  ;	0x105 : 1024 x  768 x 8bit
    16                                  ;	0x107 : 1280 x 1024 x 8bit(qemu无法使用,VMware可以)
    17                                  ;	0x0112	:	640x480	x32bit	;这三个是32位色模式
    18                                  ;	0x0115	:	800x600	x32bit
    19                                  ;	0x0118	:	1024x768x32bit
    20                                  ;	更多色彩模式代码去VESA查
    21                                  
    22                                  ; BOOT_INFO
    23                                  CYLS	EQU		0x0ff0			; 设定启动区
    24                                  LEDS	EQU		0x0ff1
    25                                  VMODE	EQU		0x0ff2			; 颜色的位数
    26                                  SCRNX	EQU		0x0ff4			; 分辨率X
    27                                  SCRNY	EQU		0x0ff6			; 分辨率Y
    28                                  VRAM	EQU		0x0ff8			; 图像缓冲区开始地址
    29                                  
    30                                  		ORG		0xc200			; 程序被装载到内存0xc200的位置
    31                                  
    32                                  ; 确认VBE是否存在
    33 00000000 B80090                  		MOV		AX,0x9000
    34 00000003 8EC0                    		MOV		ES,AX
    35 00000005 BF0000                  		MOV		DI,0
    36 00000008 B8004F                  		MOV		AX,0x4f00
    37 0000000B CD10                    		INT		0x10
    38 0000000D 83F84F                  		CMP		AX,0x004f
    39 00000010 7537                    		JNE		scrn320
    40                                  
    41                                  ; 检查VBE版本
    42 00000012 268B4504                		MOV		AX,[ES:DI+4]
    43 00000016 3D0002                  		CMP		AX,0x0200
    44 00000019 722E                    		JB		scrn320			; if (AX < 0x0200) goto scrn320
    45                                  
    46                                  ; 取得画面模式信息
    47 0000001B B91801                  		MOV		CX,VBEMODE
    48 0000001E B8014F                  		MOV		AX,0x4f01
    49 00000021 CD10                    		INT		0x10
    50                                  ;		CMP		AX,0x004f
    51                                  ;		JNE		scrn320
    52                                  
    53                                  ; 画面模式信息确认
    54                                  ;		CMP		BYTE [ES:DI+0x19],8
    55                                  ;		JNE		scrn320
    56                                  ;		CMP		BYTE [ES:DI+0x1b],4
    57                                  ;		JNE		scrn320
    58                                  ;		MOV		AX,[ES:DI+0x00]
    59                                  ;		AND		AX,0x0080
    60                                  ;		JZ		scrn320			; 模式属性的bit7是0，所以放弃
    61                                  
    62                                  ; 画面模式的切换
    63 00000023 BB1841                  		MOV		BX,VBEMODE+0x4000
    64 00000026 B8024F                  		MOV		AX,0x4f02
    65 00000029 CD10                    		INT		0x10
    66 0000002B C606F20F20              		MOV		BYTE [VMODE],32	; 记录画面模式
    67 00000030 268B4512                		MOV		AX,[ES:DI+0x12]
    68 00000034 A3F40F                  		MOV		[SCRNX],AX
    69 00000037 268B4514                		MOV		AX,[ES:DI+0x14]
    70 0000003B A3F60F                  		MOV		[SCRNY],AX
    71 0000003E 26668B4528              		MOV		EAX,[ES:DI+0x28]
    72 00000043 66A3F80F                		MOV		[VRAM],EAX
    73 00000047 EB20                    		JMP		keystatus
    74                                  
    75                                  scrn320:
    76 00000049 B013                    		MOV		AL,0x13			; VGA图形、1024x768x32bit色彩
    77 0000004B B400                    		MOV		AH,0x00
    78 0000004D CD10                    		INT		0x10
    79 0000004F C606F20F20              		MOV		BYTE [VMODE],32	; 记录画面模式
    80 00000054 C706F40F0004            		MOV		WORD [SCRNX],1024
    81 0000005A C706F60F0003            		MOV		WORD [SCRNY],768
    82 00000060 66C706F80F00000A00      		MOV		DWORD [VRAM],0x000a0000
    83                                  
    84                                  ; 用BIOS取得键盘上各种LED的状态
    85                                  keystatus:
    86 00000069 B402                    		MOV		AH,0x02
    87 0000006B CD16                    		INT		0x16 			; keyboard BIOS
    88 0000006D A2F10F                  		MOV		[LEDS],AL
    89                                  
    90                                  ; 从这里开始进入32位
    91                                  ; 在osdev.org中，对于切换到受保护模式(Protected Mode)之前，有以下步骤：
    92                                  ; 禁用中断，包括NMI（如英特尔开发人员手册建议）。
    93                                  ; 启用A20 line。
    94                                  ; 加载适用于代码、数据和堆栈的段描述符"全球描述器表(GDT)"。
    95                                  
    96                                  ; PIC关闭所有中断
    97                                  ; 根据AT兼容机的规格，如果要初始化PIC，
    98                                  ; 必须在CLI之前进行，否则有事会挂起
    99                                  ; 随后进行PIC初始化
   100                                  ; 功能等同于(C语言)
   101                                  ; io_out(PIC0_IMR, 0xff);	/* 禁止主PIC中断 */
   102                                  ; io_out(PIC1_IMR, 0xff);	/* 禁止从PIC中断 */
   103                                  ; io_cli();					/* 禁止CPU中断 */
   104 00000070 B0FF                    		MOV		AL,0xff
   105 00000072 E621                    		OUT		0x21,AL			; 禁止主PIC中断(这里可以参考PIC中断控制器相关资料)
   106 00000074 90                      		NOP						; 停顿一下，防止BUG(这个对于现在来说没有太大的必要性 )
   107 00000075 E6A1                    		OUT		0xa1,AL			; 禁止从PIC中断
   108                                  
   109 00000077 FA                      		CLI						; 禁止CPU中断
   110                                  
   111                                  ; 为了能够从CPU访问1MB以上的存储器，设定A20GATE
   112                                  ; 功能等同于(C语言)
   113                                  ; #define KEYCMD_WRITE_OUTPORT		0xd1
   114                                  ; #define KBC_OUTPORT_A20G_ENABLE	0Xdf
   115                                  ; 
   116                                  ; wait_KBC_sendready();		/* keyboard.c */
   117                                  ; io_out(PORT_KEYCMD, KEYCMD_WRITE_OUTPORT);
   118                                  ; wait_KBC_sendready();
   119                                  ; io_out(PORT_KEYCMD, KBC_OUTPORT_A20G_ENABLE);
   120                                  ; wait_KBC_sendready();		/* wait_KBC_sendready是多余的，在这里是为了等待A20GATE处理完毕 */
   121 00000078 E8B500                  		CALL	waitkbdout		; 这里与wait_KBC_sendready相同(等待键盘控制电路准备完毕 P.140)
   122 0000007B B0D1                    		MOV		AL,0xd1
   123 0000007D E664                    		OUT		0x64,AL
   124 0000007F E8AE00                  		CALL	waitkbdout
   125 00000082 B0DF                    		MOV		AL,0xdf			; 激活 A20GATE,使CPU将1M以上部分的内存变为可用状态
   126 00000084 E660                    		OUT		0x60,AL
   127 00000086 E8A700                  		CALL	waitkbdout
   128                                  
   129                                  ; 转向保护模式
   130                                  ; CR0寄存器中含有控制处理器操作模式和状态的系统控制标志
   131 00000089 0F0116[6A01]            		LGDT	[GDTR0]			; 设定临时GDT
   132 0000008E 0F20C0                  		MOV		EAX,CR0			; 为了设置CR0寄存器的值
   133 00000091 6625FFFFFF7F            		AND		EAX,0x7fffffff	; 将bit31(最高位)设为0（为了禁止分页）
   134 00000097 6683C801                		OR		EAX,0x00000001	; 使bit0(最低位)为1(为了切换到保护模式)
   135 0000009B 0F22C0                  		MOV		CR0,EAX
   136 0000009E EB00                    		JMP		pipelineflush
   137                                  ; 位于此处的jmp
   138                                  ; CPU通过代入CR0进入保护模式后，需要立即执行跳转指令(P.155)
   139                                  pipelineflush:
   140 000000A0 B80800                  		MOV		AX,1*8			; 可读写的段 32bit
   141 000000A3 8ED8                    		MOV		DS,AX
   142 000000A5 8EC0                    		MOV		ES,AX
   143 000000A7 8EE0                    		MOV		FS,AX
   144 000000A9 8EE8                    		MOV		GS,AX
   145 000000AB 8ED0                    		MOV		SS,AX
   146                                  		
   147                                  ; bootpack的传送
   148                                  ; 将bootpack传送到相应的内存位置
   149 000000AD 66BE[70010000]          		MOV		ESI,bootpack	; 传送源
   150 000000B3 66BF00002800            		MOV		EDI,BOTPAK		; 传送目的地
   151 000000B9 66B900000200            		MOV		ECX,512*1024/4	; 传送数据大小
   152 000000BF E87700                  		CALL	memcpy
   153                                  		
   154                                  ; 顺便盘数据也向原来的位置传送
   155                                  
   156                                  ; 首先从引导扇区
   157                                  ; 这里一段程序的意思是从0x7c00复制512字节到DSKCAC(0x00100000)，以双字节为单位，复制次数为512/4
   158                                  ; 0x00100000是1M以后的内存
   159 000000C2 66BE007C0000            		MOV		ESI,0x7c00		; 传送源
   160 000000C8 66BF00001000            		MOV		EDI,DSKCAC		; 传送目的地
   161 000000CE 66B980000000            		MOV		ECX,512/4		; 传送数据大小
   162 000000D4 E86200                  		CALL	memcpy
   163                                  
   164                                  ; 剩下的全部
   165                                  
   166 000000D7 66BE00820000            		MOV		ESI,DSKCAC0+512	; 传送源
   167 000000DD 66BF00021000            		MOV		EDI,DSKCAC+512	; 传送目的地
   168 000000E3 66B900000000            		MOV		ECX,0
   169 000000E9 8A0EF00F                		MOV		CL,BYTE [CYLS]
   170 000000ED 6669C900120000          		IMUL	ECX,512*18*2/4
   171 000000F4 6681E980000000          		SUB		ECX,512/4		; 只减去IPL的部分
   172 000000FB E83B00                  		CALL	memcpy
   173                                  
   174                                  ; asmhead必须做的事情都做完了
   175                                  ; 剩下的就交给bootpack了
   176                                  
   177                                  ; 启动bootpack
   178                                  
   179 000000FE 66BB00002800            		MOV		EBX,BOTPAK
   180 00000104 66678B4B10              		MOV		ECX,[EBX+16]
   181 00000109 6683C103                		ADD		ECX,3			; ECX += 3;
   182 0000010D 66C1E902                		SHR		ECX,2			; ECX /= 4;		SHR是右移指令
   183 00000111 7410                    		JZ		skip			; 没有可转发的东西
   184 00000113 66678B7314              		MOV		ESI,[EBX+20]	; 传送源
   185 00000118 6601DE                  		ADD		ESI,EBX
   186 0000011B 66678B7B0C              		MOV		EDI,[EBX+12]	; 传送源
   187 00000120 E81600                  		CALL	memcpy
   188                                  skip:
   189 00000123 66678B630C              		MOV		ESP,[EBX+12]	; 堆栈初始值
   190 00000128 66EA1B0000001000        		JMP		DWORD 2*8:0x0000001b	;KaliMain入口的地址，从这里开始进入C语言		;新标的入口地址为0x00000027
   191                                  
   192                                  waitkbdout:
   193 00000130 E464                    		IN		 AL,0x64
   194 00000132 2402                    		AND		 AL,0x02
   195 00000134 E460                    		IN		 AL,0x60		; 空读，为了清空缓存中的垃圾数据
   196 00000136 75F8                    		JNZ		waitkbdout		; 如果AND的结果不是0，进入waitkbdout
   197 00000138 C3                      		RET
   198                                  
   199                                  memcpy:
   200                                  		; 这个函数用于复制内存
   201                                  		; ESI是复制源地址
   202                                  		; EDI是复制目标地址
   203                                  		; ECX是复制数据大小(传送数据大小是以dword为单位[32位]，所以用字节数除以4)
   204 00000139 66678B06                		MOV		EAX,[ESI]
   205 0000013D 6683C604                		ADD		ESI,4
   206 00000141 66678907                		MOV		[EDI],EAX
   207 00000145 6683C704                		ADD		EDI,4
   208 00000149 6683E901                		SUB		ECX,1
   209 0000014D 75EA                    		JNZ		memcpy			; 如果减法的结果不是0，则进入memcpy
   210 0000014F C3                      		RET
   211                                  ; memcpy如果不忘记加入地址复制，也可以写串命令
   212                                  
   213                                  		ALIGNB	16, DB 0		; 补充0，直到能被16整除。下同
   214                                  GDT0:
   215                                  ; 位于数据区的GDT表
   216                                  		; RESB	8
   217 00000150 00<rep 8h>              		TIMES	8 DB 0			; 选择器
   218                                  		; 写入8字节的GDT表
   219 00000158 FFFF00000092CF00        		DW		0xffff,0x0000,0x9200,0x00cf	; 可读区段32bit					; CPU使用
   220 00000160 FFFF0000289A4700        		DW		0xffff,0x0000,0x9a28,0x0047	; 可执行段32bit(用于bootpack)	; bootpack.kal使用
   221                                  		; 这一段其实跟下面两句代码差不多(kernel/dsctbl.c)：
   222                                  		; set_segmdesc(gdt + 1, 0xffffffff,   0x00000000, AR_DATA32_RW);
   223                                  		; set_segmdesc(gdt + 2, LIMIT_BOTPAK, ADR_BOTPAK, AR_CODE32_ER);
   224                                  
   225 00000168 0000                    		DW		0
   226                                  GDTR0:
   227                                  ; 这里是写一个临时的GDT
   228 0000016A 1700                    		DW		8*3-1		; GDT表的数量
   229 0000016C [50010000]              		DD		GDT0		; GDT表的地址
   230                                  
   231                                  		; ALIGNB	16
   232                                  		ALIGN 16, DB 0
   233                                  bootpack:
